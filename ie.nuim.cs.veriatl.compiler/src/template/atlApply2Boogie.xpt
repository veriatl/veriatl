«IMPORT ATL»
«IMPORT OCL»
«EXTENSION extension::JavaExtension»

«REM» «DEFINE main FOR ATL::Module-» NOT WORK EITHER «ENDREM» 
«DEFINE main FOR ATL::Module-»
«FILE "ATL_apply_single.bpl"-»

«EXPAND printApplyerForMatchRule FOREACH elements-»


«ENDFILE-»
«ENDDEFINE»



«DEFINE printApplyerForMatchRule FOR MatchedRule-»
«IF this.metaType == MatchedRule-»
procedure «name»_apply(in: ref) returns();
free requires surj_tar_model($srcHeap, $tarHeap);
//free requires isValidSrc($srcHeap);
//free requires isInstTar($tarHeap);
// link info
free requires $linkHeap[in, alloc] == true;
free requires dtype(in) == Native$TransientLink;
// rule info
free requires $linkHeap[in, TransientLink#rule]==_«name»;  
«FOREACH this.inPattern.elements AS input
»free requires Map#Domain($linkHeap[in, TransientLink#source])[_«EXPAND Library::printInPattern FOR input»];
free requires dtype(Map#Elements($linkHeap[in, TransientLink#source])[_«EXPAND Library::printInPattern FOR input»]) <: «EXPAND Library::printInPatternType(input) FOR input»;
free requires Map#Elements($linkHeap[in, TransientLink#source])[_«EXPAND Library::printInPattern FOR input»] != null;
free requires read($srcHeap, Map#Elements($linkHeap[in, TransientLink#source])[_«EXPAND Library::printInPattern FOR input»], alloc);
«ENDFOREACH»
«FOREACH this.outPattern.elements AS output
»free requires Map#Domain($linkHeap[in, TransientLink#target])[_«EXPAND Library::printOutPatternInApply FOR output»];
free requires dtype(Map#Elements($linkHeap[in, TransientLink#target])[_«EXPAND Library::printOutPatternInApply FOR output»]) <: «EXPAND Library::printOutPatternType(output) FOR output»;
free requires Map#Elements($linkHeap[in, TransientLink#target])[_«EXPAND Library::printOutPatternInApply FOR output»] != null;
free requires read($tarHeap, Map#Elements($linkHeap[in, TransientLink#target])[_«EXPAND Library::printOutPatternInApply FOR output»], alloc);
«ENDFOREACH»
// Correspondence I/O
free requires «EXPAND Library::printCoPatternInApply FOR this.inPattern» == Map#Elements($linkHeap[in, TransientLink#target])[_«EXPAND Library::printOutPatternInApply FOR this.outPattern.elements.get(0)»];
// Guard
free requires«IF this.inPattern.filter == null» true «ELSE» «EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR this.inPattern.filter» «ENDIF»;
// isValid Source model, to cooperate with resolve function.
«FOREACH this.outPattern.elements AS toBind»«
  FOREACH toBind.bindings AS bind»«
    IF bind.value.metaType == NavigationOrAttributeCallExp»«
      IF ((OclModelElement)((VariableExp)((NavigationOrAttributeCallExp)bind.value).source).referredVariable.type) != null»«
        IF isReference(bind, getFeature(((NavigationOrAttributeCallExp)bind.value).source, ((OclModelElement)((VariableExp)((NavigationOrAttributeCallExp)bind.value).source).referredVariable.type).model.name, ((VariableExp)((NavigationOrAttributeCallExp)bind.value).source).referredVariable.type.name, ((NavigationOrAttributeCallExp)bind.value).name))»
free requires dtype(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value») != class._System.array;«
        ELSEIF isPrimitive(bind, getFeature(((NavigationOrAttributeCallExp)bind.value).source, ((OclModelElement)((VariableExp)((NavigationOrAttributeCallExp)bind.value).source).referredVariable.type).model.name, ((VariableExp)((NavigationOrAttributeCallExp)bind.value).source).referredVariable.type.name, ((NavigationOrAttributeCallExp)bind.value).name))»«
      	ELSE»
free requires dtype(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value») == class._System.array;«
      	ENDIF»«
      ENDIF»«
    ENDIF»«
  ENDFOREACH»«
ENDFOREACH»
// isValid Target model, i.e. associations are populated with empty array.
«FOREACH this.outPattern.elements AS toBind»«
  FOREACH toBind.bindings AS bind»«
    IF isPrimitive(toBind, getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName))»«ELSEIF isReference(toBind, getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName))»«
    ELSE»
free requires Seq#FromArray($tarHeap, read($tarHeap, Map#Elements($linkHeap[in, TransientLink#target])[_«EXPAND Library::printOutPatternInApply FOR toBind»], «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»)) == Seq#Empty();«
    ENDIF»«
  ENDFOREACH»«
ENDFOREACH»
// modifies
modifies $tarHeap;
// Rule outcome
«FOREACH this.outPattern.elements AS toBind»
«FOREACH toBind.bindings AS bind ITERATOR it
»ensures «IF isPrimitive(toBind, getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName))
»read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)») == «EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value»;«
ELSEIF isReference(toBind, getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName))
»read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)») == getTarsBySrcs(Seq#Singleton(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value»));«
ELSE 
»«IF toBind.bindings.exists(b2 | bind != b2 && bind.propertyName == b2.propertyName)  
  »«IF it.counter0 < toBind.bindings.indexOf(toBind.bindings.selectFirst(b2 | bind != b2 && bind.propertyName == b2.propertyName))
      »«LET toBind.bindings.selectFirst(b2 | bind != b2 && bind.propertyName == b2.propertyName) AS freebind
        »dtype(read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»)) == class._System.array
&&       read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)») != null
&&       read($tarHeap, read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»), alloc)
&&       (_System.array.Length(read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»)) == _System.array.Length(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value») + _System.array.Length(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR freebind.value»))
&&       ( forall __j: int :: 0<=__j && __j<_System.array.Length(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value») ==> $Unbox(read($tarHeap, read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»), IndexField(__j))): ref == getTarsBySrcs(Seq#Singleton( $Unbox(read($srcHeap, «EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value», IndexField(__j))): ref) ))
&&       ( forall __j: int :: 0<=__j && __j<_System.array.Length(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR freebind.value») ==> $Unbox(read($tarHeap, read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»), IndexField(__j+_System.array.Length(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value»)))): ref == getTarsBySrcs(Seq#Singleton( $Unbox(read($srcHeap, «EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR freebind.value», IndexField(__j))): ref) ))«
       ENDLET»«
    ELSE» true «
    ENDIF»«
  ELSE»dtype(read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»)) == class._System.array
&&       read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)») != null
&&       read($tarHeap, read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»), alloc)
&&       (_System.array.Length(read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»)) == _System.array.Length(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value»))
&&       ( forall __j: int :: 0<=__j && __j<_System.array.Length(«EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value») ==> $Unbox(read($tarHeap, read($tarHeap, «EXPAND Library::printCoPatternInApply FOR this.inPattern», «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»), IndexField(__j))): ref == getTarsBySrcs(Seq#Singleton( $Unbox(read($srcHeap, «EXPAND OCL2BoogieInApply::printOCLExpression("$srcHeap") FOR bind.value», IndexField(__j))): ref) ))«
  ENDIF»;
«ENDIF»
«ENDFOREACH»
«ENDFOREACH»
// Frame 
ensures (forall<alpha> $o: ref, $f: Field alpha :: 
	!read(old($tarHeap), $o, alloc) ==>
		 ( read($tarHeap, $o, $f) == read(old($tarHeap), $o, $f))
	  || (dtype($o) == class._System.array));
ensures (forall<alpha> $o: ref, $f: Field alpha :: 
	$o != null && read(old($tarHeap), $o, alloc) ==>
		(Seq#Length(getTarsBySrcs_inverse($o)) == «this.inPattern.elements.size» && «FOREACH this.inPattern.elements AS e ITERATOR it SEPARATOR ' && '»dtype(Seq#Index(getTarsBySrcs_inverse($o), «it.counter1-1»)) <: «EXPAND Library::printInPatternType(e) FOR e»«ENDFOREACH» && «FOREACH this.outPattern.elements AS toBind
		»( dtype($o) <: «((OclModelElement)toBind.type).model.name»$«toBind.type.name» «IF toBind.bindings.size>0»&& («FOREACH toBind.bindings AS bind SEPARATOR ' || '»$f == «getFeature(toBind, ((OclModelElement)toBind.type).model.name, toBind.type.name, bind.propertyName)»«ENDFOREACH»)«ENDIF»))«
		ENDFOREACH» 
		|| (read($tarHeap, $o, $f) == read(old($tarHeap), $o, $f)));
ensures (forall<alpha> $o: ref, $f: Field alpha :: 
	$o != null && read(old($tarHeap), $o, alloc) && $o != «EXPAND Library::printCoPatternInApply FOR this.inPattern» ==> 
	(read($tarHeap, $o, $f) == read(old($tarHeap), $o, $f))
  );
// Preserving
free ensures $HeapSucc(old($tarHeap), $tarHeap);
free ensures surj_tar_model($srcHeap, $tarHeap);
«ENDIF»
«ENDDEFINE»






«DEFINE printApplyerForMatchRule FOR ModuleElement»
«ENDDEFINE»








